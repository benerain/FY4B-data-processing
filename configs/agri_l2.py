# #!/usr/bin/env python
# # -*- coding: utf-8 -*-
# # Copyright (c) 2023 Satpy developers
# #
# # This file is part of satpy.
# #
# # satpy is free software: you can redistribute it and/or modify it under the
# # terms of the GNU General Public License as published by the Free Software
# # Foundation, either version 3 of the License, or (at your option) any later
# # version.
# #
# # satpy is distributed in the hope that it will be useful, but WITHOUT ANY
# # WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# # A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# #
# # You should have received a copy of the GNU General Public License along with
# # satpy.  If not, see <http://www.gnu.org/licenses/>.

# """Reader for FY4B L2 cloud products.

# These products are generated by the FY4B AGRI sensor and have filenames like:
# AGRI-CLM_V0001_FY4B_s202308240540213_e202308240549407_c202308240557548.nc

# The four letter grouping (CLM above) indicates the product type:
#     CLM - Cloud mask
#     CLT - Cloud type
#     CTH - Cloud top height
#     CTT - Cloud top temperature

# These products are produced at the resolution of 4km at nadir.
# """

# import datetime as dt
# import logging

# import xarray as xr
# import numpy as np
# from pyproj import CRS, Proj

# from satpy._compat import cached_property
# from satpy.readers.file_handlers import BaseFileHandler

# from satpy.readers._geos_area import get_area_definition, get_area_extent
# from pyresample.geometry import AreaDefinition


# logger = logging.getLogger(__name__)


# class AGRI_L2_NC_Handler(BaseFileHandler):
#     """Satpy文件处理器，用于读取FY-4B AGRI L2级NetCDF云产品数据。"""


#     def __init__(self, filename, filename_info, filetype_info):
#         super(AGRI_L2_NC_Handler, self).__init__(filename, filename_info, filetype_info)
#         self.nc = xr.open_dataset(filename)
#         self._validate_file() 
#         self._parse_metadata() 
#         print('zzzzzzzz',filename, filename_info, filetype_info)


#     def _parse_metadata(self):
#         """提取卫星次表点、时间等元数据"""
#         self.subpoint_lon = float(self.nc["nominal_satellite_subpoint_lon"][0])
#         self.subpoint_lat = float(self.nc["nominal_satellite_subpoint_lat"][0])
#         self.satellite_height = float(self.nc["nominal_satellite_height"][0]) * 1000  # km -> m
#         self.start_time = self._parse_datetime("time_coverage_start")
#         self.end_time = self._parse_datetime("time_coverage_end")

#     def get_dataset(self, key, info):
#         var = info["file_key"]
#         logger.debug("正在读取数据集 %s", var)
#         variable = self.nc[var]

#         # 数据已经使用"x"和"y"坐标，无需重命名
#         # 添加数据集元数据
#         variable.attrs.update(key.to_dict())
#         return variable

#         # # 1. 打开NetCDF文件（禁用自动缩放，保留原始值）
#         # self.nc = xr.open_dataset(
#         #     self.filename,
#         #     decode_cf=True,
#         #     mask_and_scale=False,  # Satpy自行处理FillValue
#         #     chunks={"x": "auto", "y": "auto"}  # 分块优化读取
#         # )

#         # # 2. 校验关键元数据是否符合全圆盘要求
#         # self._validate_file()

#         # # 3. 提取基础元数据
#         # self.platform_name = self.nc.attrs["platform_ID"]
#         # self.sensor = self.nc.attrs["instrument_ID"].lower()  # 转为小写（agri）
#         # self.nlines = self.nc.sizes["y"]  # 行数（纬度方向）
#         # self.ncols = self.nc.sizes["x"]  # 列数（经度方向）
#         # self.resolution = self.nc.attrs["spatial_resolution"]  # 空间分辨率

#         # # 4. 从文件名信息获取平台简称（如filename_info["platform"]应为"FY4B"）
#         # self.platform_shortname = filename_info.get("platform", "FY4B")

#         # # 5. 解析时间范围
#         # self.start_time = self._parse_datetime("time_coverage_start")
#         # self.end_time = self._parse_datetime("time_coverage_end")

#         # # 6. 记录卫星星下点位置（用于后续区域定义）
#         # self.subpoint_lat = float(self.nc["nominal_satellite_subpoint_lat"][0])
#         # self.subpoint_lon = float(self.nc["nominal_satellite_subpoint_lon"][0])
#         # self.satellite_height = float(self.nc["nominal_satellite_height"][0])  # km

#         # # 7. 初始化其他元数据容器
#         # self._meta = None

#     def _validate_file(self):
#         """验证文件是否为FY-4B全圆盘L2数据。"""
#         # 检查观测类型是否为全圆盘
#         if self.nc.attrs.get("scene_id", "") != "Full Disk":
#             raise ValueError("仅支持全圆盘数据（scene_id需为'Full Disk'）")

#         # 验证空间分辨率是否为4km
#         if "4km" not in self.nc.attrs.get("spatial_resolution", ""):
#             raise ValueError("仅支持4km分辨率数据")

#         # 验证数据维度是否为2748x2748
#         expected_shape = (2748, 2748)
#         if (self.nc.sizes["y"], self.nc.sizes["x"]) != expected_shape:
#             raise ValueError(
#                 f"数据维度应为2748x2748，当前为{self.nc.sizes['y']}x{self.nc.sizes['x']}"
#             )

#     def _parse_datetime(self, time_field):
#         """解析ISO 8601格式的时间字符串为datetime对象。

#         Args:
#             time_field (str): 时间属性名（如'time_coverage_start'）

#         Returns:
#             datetime.datetime: 解析后的时间对象
#         """
#         time_str = self.nc.attrs.get(time_field, "")
#         try:
#             return dt.datetime.strptime(time_str, "%Y-%m-%dT%H:%M:%S.%fZ")
#         except ValueError:
#             return dt.datetime.strptime(time_str, "%Y-%m-%dT%H:%M:%SZ")

#     @property
#     def start_time(self):
#         """获取数据起始时间（datetime）"""
#         return self._start_time

#     @start_time.setter
#     def start_time(self, value):
#         self._start_time = value

#     @property
#     def end_time(self):
#         """获取数据结束时间（datetime）"""
#         return self._end_time

#     @end_time.setter
#     def end_time(self, value):
#         self._end_time = value

#     @cached_property
#     def area(self):
#         """获取表示此文件数据的区域定义（缓存属性）。"""
#         return self._get_area_def()

#     def get_area_def(self, dsid):
#         """获取数据集的区域定义。
        
#         Args:
#             dsid: 数据集标识符（未使用）
            
#         Returns:
#             AreaDefinition: 区域定义对象
#         """
#         del dsid  # 未使用此参数
#         return self.area

#     def _get_area_def(self):
#         """创建FY4B AGRI L2数据的区域定义。
        
#         Returns:
#             AreaDefinition: 包含地理投影信息的区域定义
            
#         Raises:
#             ValueError: 如果数据尺寸不匹配标准全圆盘尺寸
#         """
#         logger.info("FY4B AGRI L2云产品缺少生成精确区域定义所需的完整元数据，"
#                    "将使用标准FY4B全圆盘投影（卫星次表点东经105.0°）。")

#         # 基本检查以确保我们处理的是全圆盘（4km）场景
#         if self.nlines != 2748 or self.ncols != 2748:
#             raise ValueError("输入的L2文件不是标准FY4B全圆盘场景。当前仅支持全圆盘数据。")

#         # 从卫星数据获取次表点经度，如果获取失败则使用标准值（105.0°E）
#         ssp_lon = self.subpoint_lon if hasattr(self, 'subpoint_lon') else 105.0
        
#         # 使用FY4B标准投影参数创建投影字典
#         # CFAC/LFAC值根据4km分辨率计算
#         pdict = {
#             "cfac": 10233138,  # 适用于4km数据的列向因子
#             "lfac": 10233138,  # 适用于4km数据的行向因子
#             "coff": 1373.5,    # 列偏移量（2748/2-0.5）
#             "loff": 1373.5,    # 行偏移量（2748/2-0.5）
#             "a": 6378137.0,    # 地球椭球体长半轴（米）
#             "b": 6356752.3,    # 地球椭球体短半轴（米）
#             "h": 35786000.0,   # 卫星高度（米），如果有数据则使用实际值
#             "ssp_lon": ssp_lon,# 卫星次表点经度
#             "nlines": self.nlines,  # 行数
#             "ncols": self.ncols,    # 列数
#             "scandir": "N2S"        # 扫描方向（北到南）
#         }
        
#         # 如果有卫星高度数据，则使用实际值（km转换为m）
#         if hasattr(self, 'satellite_height'):
#             pdict["h"] = self.satellite_height * 1000.0
            
#         # 计算区域范围
#         aex = get_area_extent(pdict)
        
#         # 添加区域名称和描述
#         pdict["a_name"] = "FY4B_AGRI_Area"
#         pdict["a_desc"] = "FY4B AGRI Full Disk area"
#         pdict["p_id"] = f"geos{self.platform_shortname}"
        
#         return get_area_definition(pdict, aex)






import xarray as xr
import datetime as dt
import logging
from satpy.readers.file_handlers import BaseFileHandler
from pyresample.geometry import AreaDefinition

# logger = logging.getLogger(__name__)

# class AGRI_L2_NC_Handler(BaseFileHandler):
#     def __init__(self, filename, filename_info, filetype_info):
#         super(AGRI_L2_NC_Handler, self).__init__(filename, filename_info, filetype_info)
#         self.nc = xr.open_dataset(filename, decode_cf=False)  # ✅ 禁用自动解码
#         # self._validate_file()
#         # self._parse_metadata()
#         # print ( f"🟢 初始化处理器，文件: { filename } " ) # 调试输出


#     def available_datasets(self, configured_datasets):
#         for is_avail, ds_info in configured_datasets:
#             if ds_info.get("name") == "CLM":
#                 # 动态补充元数据（如分辨率）
#                 ds_info.update({
#                     "resolution": self.filename_info["resolution"],
#                 })
#                 yield True, ds_info  # 标记为可加载
#             else:
#                 yield is_avail, ds_info


#     @property
#     def start_time(self):
#         return self.filename_info["start_time"]

#     @property
#     def end_time(self):
#         return self.filename_info["end_time"]
    
#     def get_dataset(self, dataset_id, ds_info):
#         """实际加载数据"""
#         if dataset_id['name'] == 'CLM':
#             data = self.nc['CLM'].values  # 从文件中读取变量
#             return xr.DataArray(
#                 data, 
#                 dims=('y', 'x'), 
#                 attrs={
#                     **ds_info,
#                     'area': self.get_area_def(dataset_id)  # 确保定义 get_area_def 方法
#                 }
#             )
#         return None

#     def get_dataset(self, dataset_id, ds_info):
#         if dataset_id["name"] == "CLM":
#             # 实际读取数据的逻辑（示例）
#             data = self.nc["CLM"].values
#             return xr.DataArray(data, dims=("y", "x"), attrs=ds_info)
#         return None
    


RESOLUTION_LIST = [250, 500, 1000, 2000, 4000]



from satpy.readers.netcdf_utils import NetCDF4FileHandler  # 改为继承 NetCDF 处理器
from satpy.readers.fy4_base import FY4Base  # 假设 FY4Base 在 fy4_base.py 中
from satpy.readers._geos_area import get_area_extent, get_area_definition

class AGRI_L2_NC_Handler( NetCDF4FileHandler):  
    def __init__(self, filename, filename_info, filetype_info):

        super().__init__(filename, filename_info, filetype_info)

        self.nc = xr.open_dataset(filename, decode_cf=False)


        # info of 250m, 500m, 1km, 2km and 4km data
        self._COFF_list = [21983.5, 10991.5, 5495.5, 2747.5, 1373.5]
        self._LOFF_list = [21983.5, 10991.5, 5495.5, 2747.5, 1373.5]

        self._CFAC_list = [163730199.0, 81865099.0, 40932549.0, 20466274.0, 10233137.0]
        self._LFAC_list = [163730199.0, 81865099.0, 40932549.0, 20466274.0, 10233137.0]


        self.subpoint_lon = float(filename_info['longitude'][:-1])
        if filename_info['longitude'][-1] == 'W':
            self.subpoint_lon *= -1
        self.subpoint_lat = 0.0

        # self.satellite_height = 35786000.0 * 1000
        self.satellite_height = float(self.nc["nominal_satellite_height"].values[0]) * 1000

        # 正确：使用文件中声明的GRS80标准
        # self.a = 6378137.0  # 长半轴（WGS84）
        # self.b = 6356752.3  # 短半轴（WGS84）
        self.a = 6378137.0   # GRS80长半轴
        self.b = 6356752.3   # GRS80短半轴

        # 固定参数（根据文件维度）
        self.ncols = self.nc.dims["x"]
        self.nlines = self.nc.dims["y"]


        self.sensor = "AGRI"  # 强制指定传感器类型




    def available_datasets(self, configured_datasets):
        for is_avail, ds_info in configured_datasets:
            if ds_info.get("name") == "CLM":
                # 动态补充元数据（如分辨率）
                ds_info.update({
                    "resolution": self.filename_info["resolution"],
                })
                yield True, ds_info  # 标记为可加载
            else:
                yield is_avail, ds_info

    def get_dataset(self, dataset_id, dataset_info):
        """读取数据集（例如云掩膜）"""
        if dataset_id["name"] == "CLM":
            data = self.nc["CLM"]
            data.attrs.update({
                "units": "1",
                "standard_name": "Cloud_Mask",
                "platform_name": "FY-4B",
                "sensor": "AGRI",
                "fill_value": 127,
                "valid_range": (0, 126),
                'area': self.get_area_def(dataset_id) 
            })
            return data
        
        elif dataset_id["name"] == "DQF":
            data = self.nc["DQF"]
            data.attrs.update({
                "standard_name": "status_flag",
                "fill_value": 127,
                "valid_range": (0, 6),
                "flag_meanings": "0: INVALID_CMASK_RETREVAL; 1: VALID_CMASK_RETRIEVAL; 2: CMASK_OUTSIDE_SEN_ZEN_RANGE; 3 INVALID_CMASK_BAD_CHN11; 4: REDUCED_QUAL_BAD_CHN3.9; 5: REDUCED_QUAL_BAD_CHN0.64; 6:REDUCED_QUAL_BAD_OTHER.",  # 补充完整描述
                "flag_values": [0, 1, 2, 3, 4, 5, 6],
            })
            return data

    def get_area_def(self, dataset_id):
        """生成 AreaDefinition"""
        res = int ( self . filename_info [ "resolution" ] )
        pdict = { }
        # 从文件变量获取行列起始位置（假设L2数据是全盘，起始位置为0）
        pdict["coff"] = self._COFF_list[RESOLUTION_LIST.index(res)] - 0 + 1  # begin_cols=0
        pdict["loff"] = -self._LOFF_list[RESOLUTION_LIST.index(res)] + (self.nc.dims["y"] - 1) + 1  # end_lines=2747

        pdict["cfac"] = self._CFAC_list[RESOLUTION_LIST.index(res)]
        pdict["lfac"] = self._LFAC_list[RESOLUTION_LIST.index(res)]

        pdict["a"] = self.a
        pdict["b"] = self.b
        pdict["h"] = self.satellite_height
        pdict["ssp_lon"] = self.subpoint_lon
        pdict["nlines"] = self.nlines
        pdict["ncols"] = self.ncols

         # 其他固定参数（与文件全局属性一致）
        pdict["scandir"] = "N2S"  # 扫描方向（北→南，固定值）
        pdict["a_desc"] = self.nc.attrs["Title"]  # 如 "FY4B AGRI L2 Cloud Mask"
        pdict["a_name"] = f"{self.nc.attrs['scene_id'].replace(' ', '_')}_{res}m"  # 如 "Full_Disk_4000m"
        pdict["p_id"] = f"{self.nc.attrs['platform_ID']}, {res}m"  # 如 "FY4B, 4000m"
        

        area_extent = get_area_extent(pdict)
        area_extent = (
            area_extent[0],
            area_extent[1],
            area_extent[2],
            area_extent[3]
        )

        # area = get_area_definition(pdict, area_extent)


        area = get_area_definition(
            pdict,
            area_extent
         
        )
        return area
        

        # return AreaDefinition(
        #     area_id="FY4B_AGRI_Full_Disk",
        #     description="FY4B AGRI Full Disk (4km)",
        #     projection={
        #         "proj": "geos",
        #         "lon_0": self.subpoint_lon,
        #         "a": self.a,
        #         "b": self.b,
        #         "h": self.satellite_height,
        #         "units": "m",
        #     },
        #     width=self.ncols,
        #     height=self.nlines,
        #     area_extent=(
        #         -self.ncols / 2 * 4000,  # 左下角X (meters)
        #         -self.nlines / 2 * 4000, # 左下角Y (meters)
        #         self.ncols / 2 * 4000,   # 右上角X (meters)
        #         self.nlines / 2 * 4000   # 右上角Y (meters)
        #     )
        # )

    @property
    def start_time(self):
        return self.filename_info["start_time"]

    @property
    def end_time(self):
        return self.filename_info["end_time"]