# #!/usr/bin/env python
# # -*- coding: utf-8 -*-
# # Copyright (c) 2023 Satpy developers
# #
# # This file is part of satpy.
# #
# # satpy is free software: you can redistribute it and/or modify it under the
# # terms of the GNU General Public License as published by the Free Software
# # Foundation, either version 3 of the License, or (at your option) any later
# # version.
# #
# # satpy is distributed in the hope that it will be useful, but WITHOUT ANY
# # WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# # A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# #
# # You should have received a copy of the GNU General Public License along with
# # satpy.  If not, see <http://www.gnu.org/licenses/>.

# """Reader for FY4B L2 cloud products.

# These products are generated by the FY4B AGRI sensor and have filenames like:
# AGRI-CLM_V0001_FY4B_s202308240540213_e202308240549407_c202308240557548.nc

# The four letter grouping (CLM above) indicates the product type:
#     CLM - Cloud mask
#     CLT - Cloud type
#     CTH - Cloud top height
#     CTT - Cloud top temperature

# These products are produced at the resolution of 4km at nadir.
# """

# import datetime as dt
# import logging

# import xarray as xr
# import numpy as np
# from pyproj import CRS, Proj

# from satpy._compat import cached_property
# from satpy.readers.file_handlers import BaseFileHandler

# from satpy.readers._geos_area import get_area_definition, get_area_extent
# from pyresample.geometry import AreaDefinition


# logger = logging.getLogger(__name__)


# class AGRI_L2_NC_Handler(BaseFileHandler):
#     """Satpyæ–‡ä»¶å¤„ç†å™¨ï¼Œç”¨äºè¯»å–FY-4B AGRI L2çº§NetCDFäº‘äº§å“æ•°æ®ã€‚"""


#     def __init__(self, filename, filename_info, filetype_info):
#         super(AGRI_L2_NC_Handler, self).__init__(filename, filename_info, filetype_info)
#         self.nc = xr.open_dataset(filename)
#         self._validate_file() 
#         self._parse_metadata() 
#         print('zzzzzzzz',filename, filename_info, filetype_info)


#     def _parse_metadata(self):
#         """æå–å«æ˜Ÿæ¬¡è¡¨ç‚¹ã€æ—¶é—´ç­‰å…ƒæ•°æ®"""
#         self.subpoint_lon = float(self.nc["nominal_satellite_subpoint_lon"][0])
#         self.subpoint_lat = float(self.nc["nominal_satellite_subpoint_lat"][0])
#         self.satellite_height = float(self.nc["nominal_satellite_height"][0]) * 1000  # km -> m
#         self.start_time = self._parse_datetime("time_coverage_start")
#         self.end_time = self._parse_datetime("time_coverage_end")

#     def get_dataset(self, key, info):
#         var = info["file_key"]
#         logger.debug("æ­£åœ¨è¯»å–æ•°æ®é›† %s", var)
#         variable = self.nc[var]

#         # æ•°æ®å·²ç»ä½¿ç”¨"x"å’Œ"y"åæ ‡ï¼Œæ— éœ€é‡å‘½å
#         # æ·»åŠ æ•°æ®é›†å…ƒæ•°æ®
#         variable.attrs.update(key.to_dict())
#         return variable

#         # # 1. æ‰“å¼€NetCDFæ–‡ä»¶ï¼ˆç¦ç”¨è‡ªåŠ¨ç¼©æ”¾ï¼Œä¿ç•™åŸå§‹å€¼ï¼‰
#         # self.nc = xr.open_dataset(
#         #     self.filename,
#         #     decode_cf=True,
#         #     mask_and_scale=False,  # Satpyè‡ªè¡Œå¤„ç†FillValue
#         #     chunks={"x": "auto", "y": "auto"}  # åˆ†å—ä¼˜åŒ–è¯»å–
#         # )

#         # # 2. æ ¡éªŒå…³é”®å…ƒæ•°æ®æ˜¯å¦ç¬¦åˆå…¨åœ†ç›˜è¦æ±‚
#         # self._validate_file()

#         # # 3. æå–åŸºç¡€å…ƒæ•°æ®
#         # self.platform_name = self.nc.attrs["platform_ID"]
#         # self.sensor = self.nc.attrs["instrument_ID"].lower()  # è½¬ä¸ºå°å†™ï¼ˆagriï¼‰
#         # self.nlines = self.nc.sizes["y"]  # è¡Œæ•°ï¼ˆçº¬åº¦æ–¹å‘ï¼‰
#         # self.ncols = self.nc.sizes["x"]  # åˆ—æ•°ï¼ˆç»åº¦æ–¹å‘ï¼‰
#         # self.resolution = self.nc.attrs["spatial_resolution"]  # ç©ºé—´åˆ†è¾¨ç‡

#         # # 4. ä»æ–‡ä»¶åä¿¡æ¯è·å–å¹³å°ç®€ç§°ï¼ˆå¦‚filename_info["platform"]åº”ä¸º"FY4B"ï¼‰
#         # self.platform_shortname = filename_info.get("platform", "FY4B")

#         # # 5. è§£ææ—¶é—´èŒƒå›´
#         # self.start_time = self._parse_datetime("time_coverage_start")
#         # self.end_time = self._parse_datetime("time_coverage_end")

#         # # 6. è®°å½•å«æ˜Ÿæ˜Ÿä¸‹ç‚¹ä½ç½®ï¼ˆç”¨äºåç»­åŒºåŸŸå®šä¹‰ï¼‰
#         # self.subpoint_lat = float(self.nc["nominal_satellite_subpoint_lat"][0])
#         # self.subpoint_lon = float(self.nc["nominal_satellite_subpoint_lon"][0])
#         # self.satellite_height = float(self.nc["nominal_satellite_height"][0])  # km

#         # # 7. åˆå§‹åŒ–å…¶ä»–å…ƒæ•°æ®å®¹å™¨
#         # self._meta = None

#     def _validate_file(self):
#         """éªŒè¯æ–‡ä»¶æ˜¯å¦ä¸ºFY-4Bå…¨åœ†ç›˜L2æ•°æ®ã€‚"""
#         # æ£€æŸ¥è§‚æµ‹ç±»å‹æ˜¯å¦ä¸ºå…¨åœ†ç›˜
#         if self.nc.attrs.get("scene_id", "") != "Full Disk":
#             raise ValueError("ä»…æ”¯æŒå…¨åœ†ç›˜æ•°æ®ï¼ˆscene_idéœ€ä¸º'Full Disk'ï¼‰")

#         # éªŒè¯ç©ºé—´åˆ†è¾¨ç‡æ˜¯å¦ä¸º4km
#         if "4km" not in self.nc.attrs.get("spatial_resolution", ""):
#             raise ValueError("ä»…æ”¯æŒ4kmåˆ†è¾¨ç‡æ•°æ®")

#         # éªŒè¯æ•°æ®ç»´åº¦æ˜¯å¦ä¸º2748x2748
#         expected_shape = (2748, 2748)
#         if (self.nc.sizes["y"], self.nc.sizes["x"]) != expected_shape:
#             raise ValueError(
#                 f"æ•°æ®ç»´åº¦åº”ä¸º2748x2748ï¼Œå½“å‰ä¸º{self.nc.sizes['y']}x{self.nc.sizes['x']}"
#             )

#     def _parse_datetime(self, time_field):
#         """è§£æISO 8601æ ¼å¼çš„æ—¶é—´å­—ç¬¦ä¸²ä¸ºdatetimeå¯¹è±¡ã€‚

#         Args:
#             time_field (str): æ—¶é—´å±æ€§åï¼ˆå¦‚'time_coverage_start'ï¼‰

#         Returns:
#             datetime.datetime: è§£æåçš„æ—¶é—´å¯¹è±¡
#         """
#         time_str = self.nc.attrs.get(time_field, "")
#         try:
#             return dt.datetime.strptime(time_str, "%Y-%m-%dT%H:%M:%S.%fZ")
#         except ValueError:
#             return dt.datetime.strptime(time_str, "%Y-%m-%dT%H:%M:%SZ")

#     @property
#     def start_time(self):
#         """è·å–æ•°æ®èµ·å§‹æ—¶é—´ï¼ˆdatetimeï¼‰"""
#         return self._start_time

#     @start_time.setter
#     def start_time(self, value):
#         self._start_time = value

#     @property
#     def end_time(self):
#         """è·å–æ•°æ®ç»“æŸæ—¶é—´ï¼ˆdatetimeï¼‰"""
#         return self._end_time

#     @end_time.setter
#     def end_time(self, value):
#         self._end_time = value

#     @cached_property
#     def area(self):
#         """è·å–è¡¨ç¤ºæ­¤æ–‡ä»¶æ•°æ®çš„åŒºåŸŸå®šä¹‰ï¼ˆç¼“å­˜å±æ€§ï¼‰ã€‚"""
#         return self._get_area_def()

#     def get_area_def(self, dsid):
#         """è·å–æ•°æ®é›†çš„åŒºåŸŸå®šä¹‰ã€‚
        
#         Args:
#             dsid: æ•°æ®é›†æ ‡è¯†ç¬¦ï¼ˆæœªä½¿ç”¨ï¼‰
            
#         Returns:
#             AreaDefinition: åŒºåŸŸå®šä¹‰å¯¹è±¡
#         """
#         del dsid  # æœªä½¿ç”¨æ­¤å‚æ•°
#         return self.area

#     def _get_area_def(self):
#         """åˆ›å»ºFY4B AGRI L2æ•°æ®çš„åŒºåŸŸå®šä¹‰ã€‚
        
#         Returns:
#             AreaDefinition: åŒ…å«åœ°ç†æŠ•å½±ä¿¡æ¯çš„åŒºåŸŸå®šä¹‰
            
#         Raises:
#             ValueError: å¦‚æœæ•°æ®å°ºå¯¸ä¸åŒ¹é…æ ‡å‡†å…¨åœ†ç›˜å°ºå¯¸
#         """
#         logger.info("FY4B AGRI L2äº‘äº§å“ç¼ºå°‘ç”Ÿæˆç²¾ç¡®åŒºåŸŸå®šä¹‰æ‰€éœ€çš„å®Œæ•´å…ƒæ•°æ®ï¼Œ"
#                    "å°†ä½¿ç”¨æ ‡å‡†FY4Bå…¨åœ†ç›˜æŠ•å½±ï¼ˆå«æ˜Ÿæ¬¡è¡¨ç‚¹ä¸œç»105.0Â°ï¼‰ã€‚")

#         # åŸºæœ¬æ£€æŸ¥ä»¥ç¡®ä¿æˆ‘ä»¬å¤„ç†çš„æ˜¯å…¨åœ†ç›˜ï¼ˆ4kmï¼‰åœºæ™¯
#         if self.nlines != 2748 or self.ncols != 2748:
#             raise ValueError("è¾“å…¥çš„L2æ–‡ä»¶ä¸æ˜¯æ ‡å‡†FY4Bå…¨åœ†ç›˜åœºæ™¯ã€‚å½“å‰ä»…æ”¯æŒå…¨åœ†ç›˜æ•°æ®ã€‚")

#         # ä»å«æ˜Ÿæ•°æ®è·å–æ¬¡è¡¨ç‚¹ç»åº¦ï¼Œå¦‚æœè·å–å¤±è´¥åˆ™ä½¿ç”¨æ ‡å‡†å€¼ï¼ˆ105.0Â°Eï¼‰
#         ssp_lon = self.subpoint_lon if hasattr(self, 'subpoint_lon') else 105.0
        
#         # ä½¿ç”¨FY4Bæ ‡å‡†æŠ•å½±å‚æ•°åˆ›å»ºæŠ•å½±å­—å…¸
#         # CFAC/LFACå€¼æ ¹æ®4kmåˆ†è¾¨ç‡è®¡ç®—
#         pdict = {
#             "cfac": 10233138,  # é€‚ç”¨äº4kmæ•°æ®çš„åˆ—å‘å› å­
#             "lfac": 10233138,  # é€‚ç”¨äº4kmæ•°æ®çš„è¡Œå‘å› å­
#             "coff": 1373.5,    # åˆ—åç§»é‡ï¼ˆ2748/2-0.5ï¼‰
#             "loff": 1373.5,    # è¡Œåç§»é‡ï¼ˆ2748/2-0.5ï¼‰
#             "a": 6378137.0,    # åœ°çƒæ¤­çƒä½“é•¿åŠè½´ï¼ˆç±³ï¼‰
#             "b": 6356752.3,    # åœ°çƒæ¤­çƒä½“çŸ­åŠè½´ï¼ˆç±³ï¼‰
#             "h": 35786000.0,   # å«æ˜Ÿé«˜åº¦ï¼ˆç±³ï¼‰ï¼Œå¦‚æœæœ‰æ•°æ®åˆ™ä½¿ç”¨å®é™…å€¼
#             "ssp_lon": ssp_lon,# å«æ˜Ÿæ¬¡è¡¨ç‚¹ç»åº¦
#             "nlines": self.nlines,  # è¡Œæ•°
#             "ncols": self.ncols,    # åˆ—æ•°
#             "scandir": "N2S"        # æ‰«ææ–¹å‘ï¼ˆåŒ—åˆ°å—ï¼‰
#         }
        
#         # å¦‚æœæœ‰å«æ˜Ÿé«˜åº¦æ•°æ®ï¼Œåˆ™ä½¿ç”¨å®é™…å€¼ï¼ˆkmè½¬æ¢ä¸ºmï¼‰
#         if hasattr(self, 'satellite_height'):
#             pdict["h"] = self.satellite_height * 1000.0
            
#         # è®¡ç®—åŒºåŸŸèŒƒå›´
#         aex = get_area_extent(pdict)
        
#         # æ·»åŠ åŒºåŸŸåç§°å’Œæè¿°
#         pdict["a_name"] = "FY4B_AGRI_Area"
#         pdict["a_desc"] = "FY4B AGRI Full Disk area"
#         pdict["p_id"] = f"geos{self.platform_shortname}"
        
#         return get_area_definition(pdict, aex)






import xarray as xr
import datetime as dt
import logging
from satpy.readers.file_handlers import BaseFileHandler
from pyresample.geometry import AreaDefinition

# logger = logging.getLogger(__name__)

# class AGRI_L2_NC_Handler(BaseFileHandler):
#     def __init__(self, filename, filename_info, filetype_info):
#         super(AGRI_L2_NC_Handler, self).__init__(filename, filename_info, filetype_info)
#         self.nc = xr.open_dataset(filename, decode_cf=False)  # âœ… ç¦ç”¨è‡ªåŠ¨è§£ç 
#         # self._validate_file()
#         # self._parse_metadata()
#         # print ( f"ğŸŸ¢ åˆå§‹åŒ–å¤„ç†å™¨ï¼Œæ–‡ä»¶: { filename } " ) # è°ƒè¯•è¾“å‡º


#     def available_datasets(self, configured_datasets):
#         for is_avail, ds_info in configured_datasets:
#             if ds_info.get("name") == "CLM":
#                 # åŠ¨æ€è¡¥å……å…ƒæ•°æ®ï¼ˆå¦‚åˆ†è¾¨ç‡ï¼‰
#                 ds_info.update({
#                     "resolution": self.filename_info["resolution"],
#                 })
#                 yield True, ds_info  # æ ‡è®°ä¸ºå¯åŠ è½½
#             else:
#                 yield is_avail, ds_info


#     @property
#     def start_time(self):
#         return self.filename_info["start_time"]

#     @property
#     def end_time(self):
#         return self.filename_info["end_time"]
    
#     def get_dataset(self, dataset_id, ds_info):
#         """å®é™…åŠ è½½æ•°æ®"""
#         if dataset_id['name'] == 'CLM':
#             data = self.nc['CLM'].values  # ä»æ–‡ä»¶ä¸­è¯»å–å˜é‡
#             return xr.DataArray(
#                 data, 
#                 dims=('y', 'x'), 
#                 attrs={
#                     **ds_info,
#                     'area': self.get_area_def(dataset_id)  # ç¡®ä¿å®šä¹‰ get_area_def æ–¹æ³•
#                 }
#             )
#         return None

#     def get_dataset(self, dataset_id, ds_info):
#         if dataset_id["name"] == "CLM":
#             # å®é™…è¯»å–æ•°æ®çš„é€»è¾‘ï¼ˆç¤ºä¾‹ï¼‰
#             data = self.nc["CLM"].values
#             return xr.DataArray(data, dims=("y", "x"), attrs=ds_info)
#         return None
    


RESOLUTION_LIST = [250, 500, 1000, 2000, 4000]



from satpy.readers.netcdf_utils import NetCDF4FileHandler  # æ”¹ä¸ºç»§æ‰¿ NetCDF å¤„ç†å™¨
from satpy.readers.fy4_base import FY4Base  # å‡è®¾ FY4Base åœ¨ fy4_base.py ä¸­
from satpy.readers._geos_area import get_area_extent, get_area_definition

class AGRI_L2_NC_Handler( NetCDF4FileHandler):  
    def __init__(self, filename, filename_info, filetype_info):

        super().__init__(filename, filename_info, filetype_info)

        self.nc = xr.open_dataset(filename, decode_cf=False)


        # info of 250m, 500m, 1km, 2km and 4km data
        self._COFF_list = [21983.5, 10991.5, 5495.5, 2747.5, 1373.5]
        self._LOFF_list = [21983.5, 10991.5, 5495.5, 2747.5, 1373.5]

        self._CFAC_list = [163730199.0, 81865099.0, 40932549.0, 20466274.0, 10233137.0]
        self._LFAC_list = [163730199.0, 81865099.0, 40932549.0, 20466274.0, 10233137.0]


        self.subpoint_lon = float(filename_info['longitude'][:-1])
        if filename_info['longitude'][-1] == 'W':
            self.subpoint_lon *= -1
        self.subpoint_lat = 0.0

        # self.satellite_height = 35786000.0 * 1000
        self.satellite_height = float(self.nc["nominal_satellite_height"].values[0]) * 1000

        # æ­£ç¡®ï¼šä½¿ç”¨æ–‡ä»¶ä¸­å£°æ˜çš„GRS80æ ‡å‡†
        # self.a = 6378137.0  # é•¿åŠè½´ï¼ˆWGS84ï¼‰
        # self.b = 6356752.3  # çŸ­åŠè½´ï¼ˆWGS84ï¼‰
        self.a = 6378137.0   # GRS80é•¿åŠè½´
        self.b = 6356752.3   # GRS80çŸ­åŠè½´

        # å›ºå®šå‚æ•°ï¼ˆæ ¹æ®æ–‡ä»¶ç»´åº¦ï¼‰
        self.ncols = self.nc.dims["x"]
        self.nlines = self.nc.dims["y"]


        self.sensor = "AGRI"  # å¼ºåˆ¶æŒ‡å®šä¼ æ„Ÿå™¨ç±»å‹




    def available_datasets(self, configured_datasets):
        for is_avail, ds_info in configured_datasets:
            if ds_info.get("name") == "CLM":
                # åŠ¨æ€è¡¥å……å…ƒæ•°æ®ï¼ˆå¦‚åˆ†è¾¨ç‡ï¼‰
                ds_info.update({
                    "resolution": self.filename_info["resolution"],
                })
                yield True, ds_info  # æ ‡è®°ä¸ºå¯åŠ è½½
            else:
                yield is_avail, ds_info

    def get_dataset(self, dataset_id, dataset_info):
        """è¯»å–æ•°æ®é›†ï¼ˆä¾‹å¦‚äº‘æ©è†œï¼‰"""
        if dataset_id["name"] == "CLM":
            data = self.nc["CLM"]
            data.attrs.update({
                "units": "1",
                "standard_name": "Cloud_Mask",
                "platform_name": "FY-4B",
                "sensor": "AGRI",
                "fill_value": 127,
                "valid_range": (0, 126),
                'area': self.get_area_def(dataset_id) 
            })
            return data
        
        elif dataset_id["name"] == "DQF":
            data = self.nc["DQF"]
            data.attrs.update({
                "standard_name": "status_flag",
                "fill_value": 127,
                "valid_range": (0, 6),
                "flag_meanings": "0: INVALID_CMASK_RETREVAL; 1: VALID_CMASK_RETRIEVAL; 2: CMASK_OUTSIDE_SEN_ZEN_RANGE; 3 INVALID_CMASK_BAD_CHN11; 4: REDUCED_QUAL_BAD_CHN3.9; 5: REDUCED_QUAL_BAD_CHN0.64; 6:REDUCED_QUAL_BAD_OTHER.",  # è¡¥å……å®Œæ•´æè¿°
                "flag_values": [0, 1, 2, 3, 4, 5, 6],
            })
            return data

    def get_area_def(self, dataset_id):
        """ç”Ÿæˆ AreaDefinition"""
        res = int ( self . filename_info [ "resolution" ] )
        pdict = { }
        # ä»æ–‡ä»¶å˜é‡è·å–è¡Œåˆ—èµ·å§‹ä½ç½®ï¼ˆå‡è®¾L2æ•°æ®æ˜¯å…¨ç›˜ï¼Œèµ·å§‹ä½ç½®ä¸º0ï¼‰
        pdict["coff"] = self._COFF_list[RESOLUTION_LIST.index(res)] - 0 + 1  # begin_cols=0
        pdict["loff"] = -self._LOFF_list[RESOLUTION_LIST.index(res)] + (self.nc.dims["y"] - 1) + 1  # end_lines=2747

        pdict["cfac"] = self._CFAC_list[RESOLUTION_LIST.index(res)]
        pdict["lfac"] = self._LFAC_list[RESOLUTION_LIST.index(res)]

        pdict["a"] = self.a
        pdict["b"] = self.b
        pdict["h"] = self.satellite_height
        pdict["ssp_lon"] = self.subpoint_lon
        pdict["nlines"] = self.nlines
        pdict["ncols"] = self.ncols

         # å…¶ä»–å›ºå®šå‚æ•°ï¼ˆä¸æ–‡ä»¶å…¨å±€å±æ€§ä¸€è‡´ï¼‰
        pdict["scandir"] = "N2S"  # æ‰«ææ–¹å‘ï¼ˆåŒ—â†’å—ï¼Œå›ºå®šå€¼ï¼‰
        pdict["a_desc"] = self.nc.attrs["Title"]  # å¦‚ "FY4B AGRI L2 Cloud Mask"
        pdict["a_name"] = f"{self.nc.attrs['scene_id'].replace(' ', '_')}_{res}m"  # å¦‚ "Full_Disk_4000m"
        pdict["p_id"] = f"{self.nc.attrs['platform_ID']}, {res}m"  # å¦‚ "FY4B, 4000m"
        

        area_extent = get_area_extent(pdict)
        area_extent = (
            area_extent[0],
            area_extent[1],
            area_extent[2],
            area_extent[3]
        )

        # area = get_area_definition(pdict, area_extent)


        area = get_area_definition(
            pdict,
            area_extent
         
        )
        return area
        

        # return AreaDefinition(
        #     area_id="FY4B_AGRI_Full_Disk",
        #     description="FY4B AGRI Full Disk (4km)",
        #     projection={
        #         "proj": "geos",
        #         "lon_0": self.subpoint_lon,
        #         "a": self.a,
        #         "b": self.b,
        #         "h": self.satellite_height,
        #         "units": "m",
        #     },
        #     width=self.ncols,
        #     height=self.nlines,
        #     area_extent=(
        #         -self.ncols / 2 * 4000,  # å·¦ä¸‹è§’X (meters)
        #         -self.nlines / 2 * 4000, # å·¦ä¸‹è§’Y (meters)
        #         self.ncols / 2 * 4000,   # å³ä¸Šè§’X (meters)
        #         self.nlines / 2 * 4000   # å³ä¸Šè§’Y (meters)
        #     )
        # )

    @property
    def start_time(self):
        return self.filename_info["start_time"]

    @property
    def end_time(self):
        return self.filename_info["end_time"]